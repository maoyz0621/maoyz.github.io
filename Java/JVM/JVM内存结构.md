# JVM-内存结构

![](..\image\JVM\内存结构.png)

线程私有的：

- 程序计数器
- 虚拟机栈
- 本地方法栈

线程共享的：

- 堆
- 方法区
- 直接内存

## 程序计数器

- **使用PC寄存器存储字节码指令地址有什么用呢？为什么使用PC寄存器记录当前线程的执行地址呢？**

因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。

- **PC寄存器为什么会被设定为线程私有的？**

多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。



- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域
- 在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。如果当前线程正在执行的是 Java 方法，程序计数器记录的是 JVM 字节码指令地址，如果是执行 native 方法，则是未指定值（undefined）
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- **它是唯一一个在 JVM 规范中没有规定任何 `OutOfMemoryError` 情况的区域**

## 虚拟机栈

> Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。

### 功能

java程序的运行，保存方法的局部变量、部分结果，并参与方法的调用与返回。

### 栈的存储单位

栈帧

### 栈运行原理

- JVM对栈帧**压栈**和**出栈**，遵循“先进后出/后进先出”原则。
- Java方法有两种返回函数的方式，**一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出**

### 栈帧的内部结构

每个栈帧存储：

![](..\image\JVM\栈帧内部结构.jpg)

- 局部变量表：主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）
- 操作数栈：存放方法执行过程中产生的中间计算结果
- 动态链接：**指向运行时常量池的方法引用**
- 方法返回地址：
- 一些附加信息

![](..\image\JVM\栈帧动态链接.jpg)

## 本地方法栈

### 本地方法接口

一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法。

### 本地方法栈

- 用于管理本地方法的调用
- 线程私有的

## 堆

### 内存划分

<img src="..\image\Java\堆内存.jpg" />

- 新生代
- 老年代
- 元空间（JDK1.8 之前叫永久代）：**使用的是本地内存**

#### 新生代

年轻代，所有**新对象创建的地方**。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 **Minor GC**。年轻一代被分为三个部分——伊甸园（**Eden Memory**）和两个幸存区（**Survivor Memory**，被称为from/to或s0/s1），默认比例是`8:1:1`

> **Eden** : **From Survivor** : **To Survivor** 的比例是 **8:1:1**

- 大多数新创建的对象都位于 Eden 内存空间中
- 当 Eden 空间被对象填充时，执行**Minor GC**，并将所有幸存者对象移动到一个幸存者空间中
- Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的
- 经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代



#### 老年代

通常垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。

**大对象直接进入老年代**（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝。

> 默认情况下新生代和老年代的比例是 1:2

#### 元空间



### 设置堆内存大小和OOM

- `-Xms` 用来表示堆的起始内存，等价于 `-XX:InitialHeapSize`
- `-Xmx` 用来表示堆的最大内存，等价于 `-XX:MaxHeapSize`

如果堆的内存大小超过 `-Xmx` 设定的最大内存， 就会抛出 `OutOfMemoryError` 异常。

我们通常会将 `-Xmx` 和 `-Xms` 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能

- 默认情况下，初始堆内存大小为：电脑内存大小/64
- 默认情况下，最大堆内存大小为：电脑内存大小/4

> 每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小

**`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。

**`java.lang.OutOfMemoryError: Java heap space`** ：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值。



### 对象在堆中生命周期

1. 当创建一个对象时，对象会被优先分配到新生代的 Eden 区 

- 此时 JVM 会给对象定义一个**对象年轻计数器**（`-XX:MaxTenuringThreshold`）

2. 当**Eden**空间不足时，JVM 将执行新生代的垃圾回收（Minor GC） 

- JVM 会把存活的对象转移到 **Survivor** 中，并且**对象年龄 +1**
- 对象在 **Survivor** 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1

3. 如果分配的对象超过了`-XX:PetenureSizeThreshold`，对象会**直接被分配到老年代**



### 对象的分配过程

1. new 的对象先放在伊甸园区，此区有大小限制
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
3. 然后将伊甸园中的剩余对象移动到幸存者 **Survivor0** 区
4. 如果再次触发垃圾回收，此时上次幸存下来的放到**Survivor0** 区，如果没有回收，就会放到**Survivor1**区
5. 如果再次经历垃圾回收，此时会重新放回**Survivor0** 区，接着再去**Survivor1** 区
6. 什么时候才会去养老区呢？ 默认是 15 次回收标记
7. 在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理
8. 若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常



### 逃逸分析

一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。



## 方法区

- 线程共享
- 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 `String.intern()`方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryErro`r 异常。
- JVM 关闭后方法区即被释放

### 方法区内存大小

- 元数据区大小可以使用参数 `-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 指定，替代上述原有的两个参数

与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

### 方法区内部结构

方法区用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等。

#### 类型信息

对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息

- 这个类型的完整有效名称（全名=包名.类名）
- 这个类型直接父类的完整有效名（对于 interface或是 java.lang.Object，都没有父类）
- 这个类型的修饰符（public，abstract，final 的某个子集）
- 这个类型直接接口的一个有序列表

#### 域信息

**Field**

- JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序

- 域的相关信息包括：域名称、域类型、域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）



#### 方法信息

**Method**

- 方法名称
- 方法的返回类型
- 方法参数的数量和类型
- 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）
- 方法的字符码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）
- 异常表（abstract 和 native 方法除外） 
  - 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引



### 运行时常量池

在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

- 在加载类和结构到虚拟机后，就会创建对应的运行时常量池
- 常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，**这部分内容将在类加载后存放到方法区的运行时常量池中**
- JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的
- 运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址 
  - 运行时常量池，相对于 Class 文件常量池的另一个重要特征是：**动态性**，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 `intern()` 方法就是这样的

- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。



###  全局字符串池

string pool，在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（**记住：String Pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的**）。

在每个JVM中只有一份，存放的是字符串常量和引用值。提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。



###  class文件常量池

编译的时候每个class都有的，编译阶段存放编译器生成的**字面量（Literal）和符号引用（Symbolic References）**。

1、字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。

2、符号引用是一组符号来描述所引用的目标：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符







1.布尔类型参数值

`-XX:+<option> '+'`表示启用该选项  
`-XX:-<option> '-'`表示关闭该选项  

2.数字类型参数值：

`-XX:<option>=<number>` 给选项设置一个数字类型值，可跟随单位，例如：'m'或'M'表示兆字节;'k'或'K'千字节;'g'或'G'千兆字节。32K与32768是相同大小的。

3.字符串类型参数值：

`-XX:<option>=<string>` 给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。 例如：-XX:HeapDumpPath=./dump.core



- 堆设置

1. -Xms:  初始堆大小，默认物理内存的1/64
2. -Xmx:  最大堆大小，默认物理内存的1/4，设置与-Xms一样
3. -XX:NewSize=n:  设置年轻代大小
4. -XX:NewRatio=n:  设置老年代的和年轻代的比值。如:为3，表示老年代:年轻代=3:1，年轻代占整个年轻代年老代和的1/4
5. -XX:SurvivorRatio=n:  设值年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5
6. -XX:MaxPermSize=n:  设置持久代大小
7. -Xmn:128m  设值年轻代大小
8. -XX:MetaspaceSize=128m  初始空间大小，控制matesaceGC发生的初始最小阈值。当使用的matespace空间到达了MetaspaceSize的时候，就会触发Metaspace的GC。
9. -XX:MaxMetaspaceSize=320m  最大空间
10. -XX:MaxTenuringThreshold=5  控制年轻代需要经历多少次GC晋升到老年代中的最大阈值。默认是15。 对象不一定要经历15次YGC才会晋升到老年代中。例如，当survivor区空间不够时，便会提前进入到老年代中，但这个次数一定不大于设置的最大阈值。

- 收集器设置

1. -XX:+UseSerialGC:设置串行收集器o -XX:+UseParallelGC:设置并行收集器
2. -XX:+UseParalledlOldGC:设置并行年老代收集器
3. -XX:+UseConcMarkSweepGC:设置并发收集器

- 垃圾回收统计信息

```
-Xloggc:/opt/xxx/logs/xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=100M -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCCause
```

-XX:+PrintGC     输出GC日志

-XX:+PrintGCDetails     输出GC的详细日志

-XX:+PrintGCTimeStamps    输出GC的时间戳

-XX:+PrintGCDateStamps    输出GC的日期时间戳

-XX:+PrintGCCause     输出GC的详细日志

-Xloggc:/opt/xxx/logs/xxx-gc-%t.log  设置文件目录

-XX:+UseGCLogFileRotation       设置滚动日志

-XX:NumberOfGCLogFiles=5      设置5个文件日志

-XX:GCLogFileSize=100M            设置每个日志大小



## 内存泄露和内存溢出

### 内存泄露

Memory Leak，程序在申请内存后，**无法释放已申请的内存空间**，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光，广义并通俗的说，就是：不再会被使用的对象或者变量占用的**内存不能被回收**，就是内存泄露。

最终会导致out of memory

### 内存溢出

OOM，out of memory，在申请内存时，**没有足够的内存空间供其使用**；通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。通常都是由于内存泄露导致堆栈内存不断增大，从而引发内存溢出。

#### 造成原因：

1. 一次性申请对象太多
2. 内存资源未释放
3. 本身资源不够

#### 快速定位：

通过dump定位

```
-XX:+HeapDumpOnOutOfMemoryError  -XX:HeapDumpPath=/opt/tmp/heapdump.hprof
```

打印日志，获取dmup文件，Arthas

结合jvisualvm ，找到GCRoot，查看线程栈

```
jmap -histo:live <pid>   命令，强制执行 Full GC
```

#### 如何解决：

1. 修改申请对象数量
2. 及时释放资源
3. jmap -heap 查看堆信息
