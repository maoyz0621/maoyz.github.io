# JAVA对象创建过程

## 对象的基本存储方式

- 对象的引用：存储在栈中
- 对象的实例数据：存储在堆中
- 对象的元数据：存储在方法区

> 在jdk8中为什么大于4秒钟的时候才会有偏向锁状态？
> 其实这是因为虚拟机在启动的时候对于偏向锁有延迟。
> 因为在项目启动的时候，有大量的同步块(synchronized),多个线程访问的时候，需要消除偏向锁。会很麻烦，反而会降低效率。
> -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 修改上面的jvm参数，可以开启jvm偏向锁延迟配置，延迟为0
> -XX:-UseBiasedLocking关闭偏向锁

## 对象的创建过程

|                                                              |
| :----------------------------------------------------------: |
| <img src="../image/Java/对象创建过程.png" style="zoom:80%;" /> |

### 类加载检查

首先jvm要检查类A是否已经被加载到了内存，即类的符号引用是否已经在常量池中，并且检查这个符号引用代表的类是否已被加载、解析和初始化过的。如果还没有，需要先触发类的加载、解析、初始化，然后在堆上创建对象。



### 分配内存

在**类加载检查**通过后，虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

#### 内存分配方式

1. **指针碰撞**

   如果Java堆中内存是**绝对规整**的，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为**“指针碰撞”（Bump The Pointer）**。

2. **空闲列表**

   如果Java堆中的内存并**不是规整**的，已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为**“空闲列表”（Free List）**。

> 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或 CMSFullGCsBeforeCompaction来整理内存），就通常采用空闲列表



#### 内存分配时处理并发安全问题

对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。

- CAS+失败重试：区域加锁，保证指针更新操作的原子性

- TLAB：（Thread Local Allocation Buffer）把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲区**，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，再采用上述的 CAS 进行内存分配。虚拟机是否使用TLAB，可以通过`-XX:+/-UseTLAB`参数来设定。

  

### 初始化零值

内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB的话，这一工作也可以提前至TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

| 类型                  | 默认值         |
| --------------------- | -------------- |
| byte                  | (byte)0        |
| short                 | (short)0       |
| int                   | 0              |
| long                  | 0L             |
| float                 | 0.0f           |
| double                | 0.0d           |
| boolean               | false          |
| char                  | '/uoooo'(null) |
| reference（引用类型） | null           |

### 设置对象头

虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的**对象头（Object Header）**之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。



### 执行init方法

在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，初始化才正式开始，开始调用\<init>方法完成初始复制和构造函数，所有的字段都为零值。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执 行\<init>方法（**子类的< init >方法中会首先对父类< init >方法的调用**），把对象按照程序员的意愿进行初始化，然后将内存地址赋给栈内存中的变量，这样一个真正可用的对象才算完全创建出来。

> <init> 实例初始化方法，对象构造器方法。1.父类变量初始化块/父类语句块 2.父类构造函数 3.子类变量初始化块/子类语句块 4.子类构造函数。
>
> <client> 类初始化方法，类构造器方法。1.父类静态变量初始化/父类静态语句块 2.子类静态变量初始化/子类静态语句块。



## 对象的内存布局

对象保存在堆中，由三部分组成：

- **对象头（object header）**：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。
- **实例数据（Instance Data）**：主要是存放类的数据信息，父类的信息，对象字段属性信息。

- **对齐填充（Padding）**：为了字节对齐，填充的数据，不是必须的。

|                对象实例                 |
| :-------------------------------------: |
| ![对象实例](../image/Java/对象实例.png) |

jdk8版本是默认开启指针压缩的，可以通过配置vm参数开启关闭指针压缩，`-XX:-UseCompressedOops`。

开启指针压缩可以减少对象的内存使用

### 对象头（Object Header）

对象头至少由两个**Word**组成，第一个字就是 **mark word**，第二个就是 **klass pointer**，数组类型占用3个字宽

- #### **Mark Word（标记字段）**

> 对于32位处理器 1 Word = 4 Bytes， 64位处理器 1 Word = 8 Bytes

对象的Mark Word部分占8个字节，其内容是一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。

用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁信息（锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）等。在32位JVM中的长度是32bit，在64位JVM中长度是64bit

> 工具：JOL

|               Mark Word                |
| :------------------------------------: |
| ![32位](../image/Java/MarkWord_32.png) |
| ![64位](../image/Java/MarkWord_64.png) |

- **unused**：未使用空间
- **对象的hashcode（identity hash code）**：占31bits，运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。
- **GC分代年龄（age）**：占4bits，表示对象被GC的次数，在GC过程中，如果新生代对象在Survivor区复制一次，年龄+1．当对象年龄达到设定的阈值时，对象将会进入老年代．或者有一半的的对象年龄相等，则大于该年龄的对象直接进入老年代．默认情况GC年龄阈值为15．因为age只占4位 ，所以最大值为1 1 1 1 = 15．
- **锁标志位（lock）**：占2bits，区分锁状态，00-轻量锁，01-解锁或偏向锁，10-重量锁，11-GC标记
- **biased_lock**：占1bits，是否偏向锁，由于正常锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。

> 无锁和偏向锁的锁标志都是01 ，区分的方式是通过1bit的是否为偏向锁(biased_lock)．偏向锁的这1bit等于1，无锁这一位则为0

- **偏向锁的线程ID（JavaThread）**：占54bits，偏向锁记录的线程标识，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。

- **Epoch**：占2bits，偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。

- **ptr_to_lock_record**：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。

- **ptr_to_heavyweight_monitor**：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。

> 分析synchronize锁优化和JVM垃圾回收年龄代的时候会有很大作用



> JVM中大家是否还记得对象在Suvivor中每熬过一次MinorGC，年龄就增加1，当它的年龄增加到一定程度后就会被晋升到老年代中，这个次数默认是15岁，有想过为什么是15吗？在Mark Word中可以发现标记对象分代年龄的分配的空间是4bit，而4bit能表示的最大数就是2^4-1 = 15。



- #### **类型指针（class Pointer）**

> 未开启指针压缩时，类型指针占用8byte (64bit)
>
> 开启指针压缩情况下，类型指针占用4byte (32bit)

Class对象指针（指针压缩默认开启）的大小默认是4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址，保存在元空间。

前提：

new Object()在32为系统中占用内存大小是8byte（对象头，在堆中）+ 4byte（对象的引用地址，在栈中）=12byte；

new Object()在64为系统中占用内存大小是16byte（对象头，在堆中）+ 8byte（对象的引用地址，在栈中）=24byte；

> -XX:+UseCompressedOops  JVM 会使用 32-bit的offset来代表java object的引用
>
> -XX:+UseCompressedClassPointers  (默认是开启)     表示使用压缩指针，使用32-bit的offset来代表64-bit进程中的class pointer

总结：

1. 通过指针压缩，利用对齐填充的特性，通过映射方式达到了内存地址扩展的效果
2. 指针压缩能够节省内存空间，同时提高了程序的寻址效率
3. 堆内存设置时最好不要超过32GB，这时指针压缩将会失效，造成空间的浪费
4. 此外，指针压缩不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段指针，以及引用类型数组指针

- #### **array length(数组特有)**

如果对象是一个数组，那么对象头还要有额外的空间存储数组的长度，JVM可以通过对象头中的数组长度数据来判定数组的大小，这是访问数组类型的元数据是无法得知的.　长度为4个字节

#### 不同情况下的Object Header

- 32位JVM下

```
|----------------------------------------------------------------------------------------|--------------------
|                                    Object Header (64 bits)                             |        State       
|-------------------------------------------------------|--------------------------------|--------------------
|                  Mark Word (32 bits)                  |      Klass Word (32 bits)      |                    
|-------------------------------------------------------|--------------------------------|--------------------
| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |     正常(无状态)   
|-------------------------------------------------------|--------------------------------|--------------------
|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |       偏向锁       
|-------------------------------------------------------|--------------------------------|--------------------
|               ptr_to_lock_record:30          | lock:2 |      OOP to metadata object    |       轻量锁       
|-------------------------------------------------------|--------------------------------|--------------------
|               ptr_to_heavyweight_monitor:30  | lock:2 |      OOP to metadata object    |       重量锁       
|-------------------------------------------------------|--------------------------------|--------------------
|                                              | lock:2 |      OOP to metadata object    |       GC标记       
|-------------------------------------------------------|--------------------------------|--------------------
```

- 64位JVM下

```
|----------------------------------------------------------------------------------------------------------|------------
|                                            Object Header (128 bits)                                      |    State
|------------------------------------------------------------------------------|---------------------------|------------
|                                  mark word (64 bits)                         |  klass word (64 bits)  |
|------------------------------------------------------------------------------|---------------------------|------------
| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |  OOP to metadata object   | 正常(无状态)
|------------------------------------------------------------------------------|---------------------------|------------
| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |  OOP to metadata object   |   偏向锁
|------------------------------------------------------------------------------|---------------------------|------------
|                       ptr_to_lock_record:62                         | lock:2 |  OOP to metadata object   |   轻量锁
|------------------------------------------------------------------------------|---------------------------|------------
|                     ptr_to_heavyweight_monitor:62                   | lock:2 |  OOP to metadata object   |   重量锁
|------------------------------------------------------------------------------|---------------------------|------------
|                                                                     | lock:2 |  OOP to metadata object   |   GC标记
|------------------------------------------------------------------------------|---------------------------|------------
```

- 64位JVM压缩指针

```
|---------------------------------------------------------------------------------------------------------|------------|
|                                            Object Header (96 bits)                                      |  State     |
|--------------------------------------------------------------------------------|------------------------|------------|
|                                  Mark Word (64 bits)                           | Klass Word (32 bits)   |            |
|--------------------------------------------------------------------------------|------------------------|------------|
| unused:25 | identity_hashcode:31 | cms_free:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 正常(无状态) |
|--------------------------------------------------------------------------------|------------------------|------------|
| thread:54 |       epoch:2        | cms_free:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 偏向锁      |
|--------------------------------------------------------------------------------|------------------------|------------|
|                         ptr_to_lock_record                            | lock:2 | OOP to metadata object | 轻量锁      |
|--------------------------------------------------------------------------------|------------------------|------------|
|                     ptr_to_heavyweight_monitor                        | lock:2 | OOP to metadata object | 重量锁      |
|--------------------------------------------------------------------------------|------------------------|------------|
|                                                                       | lock:2 | OOP to metadata object | GC标记     |
|--------------------------------------------------------------------------------|------------------------|------------|
```



### 实例数据（Instance Data）

包括了对象的所有成员变量，分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers普通对象指针）。

- 基本数据类型

byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节

- 引用数据类型

reference开启UseCompressedOops占4字节，不开启UseCompressedOops占8字节

> -XX:+UseCompressedOops  为4字节(默认开启) ，不开启为8字节 Oops（Ordinary Object Pointers）(成员变量的引用 比如Object o)



### 对齐补充（Padding）

由于要求对象起始地址必须是**8字节的整数倍**，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

> **为什么要对齐数据**？字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址



## 对象的访问定位

​        需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有**使用句柄**和**直接指针**两种。 

### 句柄

​        Java堆中将会划分出一块内存来作为**句柄池**，**reference**中存储的就是**对象的句柄地址**，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。

> 最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾回收时，内存地址发生变动）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。 

|                         句柄访问对象                         |
| :----------------------------------------------------------: |
| <img src="../image/Java/句柄访问对象.png" alt="句柄访问对象" style="zoom:80%;" /> |



### 直接指针

　　**reference**中直接存储的对象地址， 对象实例数据中存储类型的指针地址。

> 最大的好处就是速度更快，它节省了一次**对象实例指针定位**的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。就虚拟机HotSpot而言，它是使用**直接指针**方式进行对象访问

|                       直接指针访问对象                       |
| :----------------------------------------------------------: |
| <img src="../image/Java/直接指针访问对象.png" alt="直接指针访问对象" style="zoom:80%;" /> |


