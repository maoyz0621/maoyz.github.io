# 类加载机制

## 类的生命周期

类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。

其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。



## 类加载过程

JVM类加载机制主要分为以下五个部分：**加载、验证、准备、解析、初始化**

### 加载

查找并加载类的二级制数据。加载主要是通过**类加载器** 完成的。

1. 通过全类名获取定义此类的二进制字节流。
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。

加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（例如从jar包或者war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）

每个 Java 类都有一个引用指向加载它的 `ClassLoader`。

> 不过，数组类不是通过 `ClassLoader` 创建的，而是 JVM 在需要的时候自动创建的，数组类通过`getClassLoader()`方法获取 `ClassLoader` 的时候和该数组的元素类型的 `ClassLoader` 是一致的。

一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。

加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。



### 连接

#### 验证

这一阶段的主要目的就是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

1. 文件格式验证（Class 文件格式检查）
2. 元数据验证（字节码语义检查）
3. 字节码验证（程序语义检查）
4. 符号引用验证（类的正确性检查）

#### 准备

准备阶段是正式为**类的静态变量分配内存并设置类变量的初始值阶段**，即在**方法区**中分配这些变量所使用的内存空间。

1. 这时候进行内存分配的仅包括类变量（ Class Variables ，即**静态变量**，被 `static` 关键字修饰的变量，只与类相关，因此被称为类变量），而**不包括实例变量**。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。

2. 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。

3. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了`public static int value=8080` ，那么 value 变量在准备阶段的初始值就是 0 而不是 8080（初始化阶段才会赋值）。将value赋值为8080的`put static`指令是在程序被编译后，存放在类构造器方法之中。特殊情况：比如给 value 变量加上了 final 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

#### 解析

解析阶段是指**虚拟机将常量池中的符号引用替换为直接引用的过程**。符号引用就是class文件中的类型常量

```
CONSTANT_CLASS_info
CONSTANT_Field_info
CONSTANT_Method_info
```

##### 符号引用

符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class的文件格式中。编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中

##### 直接引用

直接引用可以是指向目标的指针，相对于偏移量或是一个能直接定位到目标的句柄，如果有了直接引用，那引用的目标必定已经在内存中存在了。

### 初始化

**执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。**

> `<clinit> ()`方法是编译之后自动生成的。

为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。



## 类加载器

虚拟机设计团队把加载动作放到JVM外部实现，以便于引用程序决定如何获取所需的类，JVM提供了三种类加载器。

### 启动类加载器

**Bootstrap ClassLoader**，最顶层的加载器。负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath 参数指定路径下的，且被虚拟机认可（按文件名识别，如tr.jar）的类

### 扩展类加载器

**Extension ClassLoader**，负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。

### 应用程序类加载器

**Application ClassLoader**，负责加载用户路径（classpath）上的类库。JVM通过双亲委派进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。

### 自定义类加载器

除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ `.class` 文件）进行加密，加载时再利用自定义的类加载器对其解密。



除了 `BootstrapClassLoader` 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 `ClassLoader`抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。



## 双亲委派模型





> Class.forName()和ClassLoader.loadClass()区别?

- `Class.forName()`: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；
- `ClassLoader.loadClass()`: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
- `Class.forName(name, initialize, loader)`带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。

