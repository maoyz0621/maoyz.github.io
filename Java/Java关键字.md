# JAVA关键字

## synchronized

- synchronized可以作用在哪里? **对象锁**和**类锁**
- synchronized本质上是通过什么保证线程安全的? 分三个方面回答：加锁和释放锁的原理，可重入原理，保证可见性原理。
- synchronized有什么样的缺陷? Java Lock是怎么弥补这些缺陷的。
- synchronized和Lock的对比，和选择?
- synchronized在使用时有何注意事项?
- synchronized修饰的方法在抛出异常时，会释放锁吗?修饰的方法，无论方法正常执行完毕还是抛出异常，**都会释放锁**。
- 多个线程等待同一个synchronized锁的时候，JVM如何选择下一个获取锁的线程?
- synchronized使得同时只有一个线程可以执行，性能比较差，有什么提升的方法?
- 我想更加灵活的控制锁的释放和获取（现在释放锁和获取锁的时机都被规定死了），怎么办?
- 什么是锁的升级和降级? 什么是JVM里的偏斜锁、轻量级锁、重量级锁?
- 不同JDK中对synchronized有何优化?



synchronized是一个悲观锁，非公平锁

- 普通方法：对象锁，锁对象默认为this，当前实例对象
- 静态方法：类锁，当前类的Class对象
- 同步方法块：括号里配置的对象

### 加锁和释放锁原理

JVM基于进入和退出monitor对象实现的。代码块同步是使用`monitorenter`和`monitorexit`指令实现的，`monitorenter`指令是在编译后插入到同步代码块开始的位置，`monitorexit`是插在方法结束处和异常处。

`monitorenter`和`monitorexit`指令，会让对象在执行，使其锁计数器加1或者减1。每一个对象在同一时间只与一个monitor(锁)相关联，而一个monitor在同一时间只能被一个线程获得，一个对象在尝试获得与这个对象相关联的monitor锁的所有权的时候，`monitorenter`指令会发生如下3种情况之一：

- monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待
- 如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加
- 这把锁已经被别的线程获取了，等待锁释放

`monitorexit指令`：释放monitor的所有权，讲monitor的计数器减1，如果减完以后，计数器 !=0，则代表刚才是重入进来的，当前线程还继续持有这把锁，如果计数器 ==0，则代表当前线程不再拥有该monitor的所有权，即释放锁。

执行过程：

- 执行`monitorenter`获取锁 
  - （monitor计数器=0，可获取锁）
  - 执行method1()方法，monitor计数器+1 -> 1 （获取到锁）
  - ...
  - 执行methodN()方法，monitor计数器+1 -> N

- 执行monitorexit命令 
  - methodN()方法执行完，monitor计数器-1 -> N-1
  - ...
  - method1()方法执行完，monitor计数器-1 -> 0 （释放了锁）
  - （monitor计数器=0，锁释放）



### 保证可见性原理

> 内存模型和happens-before规则


```java
public class MonitorDemo {
    private int a = 0;

    public synchronized void writer() {     // 1
        a++;                                // 2
    }                                       // 3

    public synchronized void reader() {    // 4
        int i = a;                         // 5
    }                                      // 6
}
```



<img src="\images\Lock\happens-before规则.png" style="zoom: 70%;" />



在图中每一个箭头连接的两个节点就代表之间的happens-before关系，黑色的是通过程序顺序规则推导出来，红色的为监视器锁规则推导而出：线程A释放锁happens-before线程B加锁，蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-before关系，通过传递性规则进一步推导的happens-before关系。

根据happens-before的定义中的一条：如果`A happens-before B`，则A的执行结果对B可见，并且A的执行顺序先于B。线程A先对共享变量A进行加一，由   `2 happens-before 5`关系可知线程A的执行结果对线程B可见，即线程B所读取到的a的值为1。



### JVM锁优化

synchronized关键字**在jdk1.6中对锁的实现引入了大量的优化，如锁粗化(Lock Coarsening)、锁消除(Lock Elimination)、轻量级锁(Lightweight Locking)、偏向锁(Biased Locking)、适应性自旋(Adaptive Spinning)等技术来减少锁操作的开销**。



### 锁升级过程

<img src="\images\Lock\synchronized锁.png" style="zoom: 50%;" />

- 无锁

- 偏向锁（Biased Lock）
- 轻量级锁（Lightweight Lock）
- 重量级锁（Heavyweight Lock）（悲观排队锁）

在几乎无竞争的条件下，使用**偏向锁（Biased Lock ）**，轻度竞争的条件下，会由**偏向锁（Biased Lock ）**升级为**轻量级锁（Lightweight Lock）**，重度竞争条件下，会由**轻量级锁（Lightweight Lock）**升级为**重量级锁（Heavyweight Lock）**

> -XX:-UseBiasedLocking     关闭偏向锁的机制

#### 偏向锁

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。只需要简单的测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。

![](\images\Lock\偏向锁.png)



#### 轻量级锁

在线程执行同步块之前，JVM会先在当前线程的栈帧中创建一个名为锁记录(`Lock Record`)的空间，用于存储锁对象目前的`Mark Word`的拷贝(JVM会将对象头中的`Mark Word`拷贝到锁记录中，官方称为`Displaced Mark Ward`)。

如果当前对象没有被锁定，那么锁标志位为01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录`Lock Record`的空间用于存储锁对象目前的`Mark Word`的拷贝。

然后，虚拟机使用CAS操作将标记字段`Mark Word`拷贝到锁记录中，并且将`Mark Word`更新为指向`Lock Record`的指针。如果更新成功了，那么这个线程就拥用了该对象的锁，并且对象`Mark Word`的锁标志位更新为(`Mark Word`中最后的2bit)00，即表示此对象处于轻量级锁定状态。

如果这个更新操作失败，JVM会检查当前的`Mark Word`中是否存在指向当前线程的栈帧的指针，如果有，说明该锁已经被获取，可以直接调用。如果没有，则说明该锁被其他线程抢占了，如果有两条以上的线程竞争同一个锁，那轻量级锁就不再有效，直接膨胀为**重量级锁**，没有获得锁的线程会被阻塞。此时，锁的标志位为`10.Mark Word`中存储的指向重量级锁的指针。

轻量级解锁时，会使用原子的CAS操作将`Displaced Mark Word`替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。两个线程同时争夺锁。



### 锁的优缺点对比

| 锁       | 优点                                                         | 缺点                                                         | 使用场景                           |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗               | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了响应速度                           | 如线程始终得不到锁竞争的线程，使用自旋会消耗CPU性能          | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不适用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗 | 追求吞吐量，同步块执行速度较长     |



## volatile

- volatile关键字的作用是什么?
- volatile能保证原子性吗? 不能保证原子性，只能保证volatile变量的单次的读/写操作具有原子性。
- 之前32位机器上共享的long和double变量的为什么要用volatile? 现在64位机器上是否也要设置呢?不需要
- i++为什么不能保证原子性?
- volatile是如何实现可见性的? 内存屏障。
- volatile是如何实现有序性的? happens-before等
- 说下volatile的应用场景?



### 作用及实现原理

轻量级的synchronized

- 禁止指令重排序
- 保证内存可见性

- 不能保证原子性，只能保证volatile变量的单次的读/写操作具有原子性。

#### 指令重排

实例化一个对象其实可以分为三个步骤：

- 分配内存空间。
- 初始化对象。
- 将内存空间的地址赋值给对应的引用。

但是由于操作系统可以**对指令进行重排序**，所以上面的过程也可能会变成如下过程：

- 分配内存空间。
- 将内存空间的地址赋值给对应的引用。
- 初始化对象

如果是这个流程，多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为`volatile`类型的变量。

##### happens-before关系

对一个 volatile域的写，happens-before 于任意后续对这个 volatile 域的读。



##### 禁止重排序

为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了**内存屏障**阻止这种重排序。

Java编译器会在生成指令系列时在适当的位置会插入**内存屏障**指令来禁止特定类型的处理器重排序。

- 在每个 volatile 写操作的前面插入一个 StoreStore 屏障。
- 在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。
- 在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。
- 在每个 volatile 读操作的后面插入一个 LoadStore 屏障。

> volatile  写是在前面和后面分别插入内存屏障
>
> volatile  读操作是在后面插入两个内存屏障。

| 内存屏障        | 说明                                                        |
| --------------- | ----------------------------------------------------------- |
| StoreStore 屏障 | 禁止上面的普通写和下面的 volatile 写重排序。                |
| StoreLoad 屏障  | 防止上面的 volatile 写与下面可能有的 volatile 读/写重排序。 |
| LoadLoad 屏障   | 禁止下面所有的普通读操作和上面的 volatile 读重排序。        |
| LoadStore 屏障  | 禁止下面所有的普通写操作和上面的 volatile 读重排序。        |

|           volatile  写           |           volatile  读           |
| :------------------------------: | :------------------------------: |
| ![](\images\Lock\内存屏障-1.png) | ![](\images\Lock\内存屏障-2.png) |



#### 保证可见性

一个线程修改了共享变量值，而另一个线程却看不到。

引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。

**内存可见性，基于内存屏障（Memory Barrier）实现**



#### 不能保证原子性

只能保证volatile变量的单次的读/写操作具有原子性。

> i++为什么不能保证原子性?

本质上i++是读、写两次操作。

- 读取i的值
- 对i加1
- 将i的值写回内存

volatile是无法保证这三个操作是具有原子性的，我们可以通过`AtomicInteger`或者`synchronized`来保证+1操作的原子性。

> 共享的long和double变量为什么要用volatile?

因为`long`和`double`两种数据类型的操作可分为高32位和低32位两部分，因此普通的`long`或`double`类型读/写可能不是原子的。因此，鼓励大家将共享的`long`和`double`变量设置为`volatile`类型，这样能保证任何情况下对`long`和`doubl`e的单次读/写操作都具有原子性。

PS：虚拟机都选择把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不把`long `和 `double` 变量专门声明为`volatile`多数情况下也是不会错的。



### 应用场景

- 状态标识

- 双重检查(double-checked)



通过**内存屏障**来防止指令被重排序?

> 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；
> 在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；



用途：

​		结合CAS，保证原子性（AtomicXxx），常用于多线程环境下的单次操作。

用volatile修饰long和double可以保证其操作原子性。



## final

1. 新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；
2. 初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（意思就是先赋值引用，再调用final值）




## DCL

Double Check Lock双检锁

```java
public class SingletonLazy {

    /**
     * 因为这个变量要在静态方法中使用，所以需要加上static修饰
     * static对象,定义成null
     * volatile 可见性
     */
    private volatile static SingletonLazy instance = null;

    /**
     * 构造方法私有化
     */
    private SingletonLazy() {
    }

    /**
     * 提供获取实例的方法
     * 定义成static
     * 双重检查加锁
     */
    public static SingletonLazy getInstance() {
        //　判断存储实例的变量是否有值
        if (instance == null) {
            //　同步块，线程安全的创建实例
            synchronized (SingletonLazy.class) {
                //　再次检查实例是否存在，如果不存在才真的创建实例
                if (instance == null) {
                    //　如果没有，就创建一个类实例，并把值赋值给存储类实例的变量
                    instance = new SingletonLazy();
                }
            }
        }
        //　如果有值，那就直接使用
        return instance;
    }
}
```



## 对象的基本存储方式

- 对象的引用：存储在栈中
- 对象的实例数据：存储在堆中
- 对象的元数据：存储在方法区

> 在jdk8中为什么大于4秒钟的时候才会有偏向锁状态？
> 其实这是因为虚拟机在启动的时候对于偏向锁有延迟。
> 因为在项目启动的时候，有大量的同步块(synchronized),多个线程访问的时候，需要消除偏向锁。会很麻烦，反而会降低效率。
> -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 修改上面的jvm参数，可以开启jvm偏向锁延迟配置，延迟为0
> -XX:-UseBiasedLocking关闭偏向锁



## 对象的内存布局

对象保存在堆中，由三部分组成：

- **对象头（object header）**：包括了关于堆对象的布局、类型、GC状态、同步状态和标识哈希码的基本信息。Java对象和vm内部对象都有一个共同的对象头格式。
- **实例数据（Instance Data）**：主要是存放类的数据信息，父类的信息，对象字段属性信息。

- **对齐填充（Padding）**：为了字节对齐，填充的数据，不是必须的。

|                对象实例                |
| :------------------------------------: |
| ![对象实例](./image/Java/对象实例.png) |

jdk8版本是默认开启指针压缩的，可以通过配置vm参数开启关闭指针压缩，-XX:-UseCompressedOops。

开启指针压缩可以减少对象的内存使用

### 对象头（Object Header）

对象头至少由两个**Word**组成，第一个字就是 **mark word**，第二个就是 **klass pointer**，数组类型占用3个字宽

- #### **Mark Word（标记字段）**

> 对于32位处理器 1 Word = 4 Bytes， 64位处理器 1 Word = 8 Bytes

对象的Mark Word部分占8个字节，其内容是一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。

用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁信息（锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）等。在32位JVM中的长度是32bit，在64位JVM中长度是64bit

> 工具：JOL

|               Mark Word               |
| :-----------------------------------: |
| ![32位](./image/Java/MarkWord_32.png) |
| ![64位](./image/Java/MarkWord_64.png) |

- **unused**：未使用空间
- **对象的hashcode（identity hash code）**：占31bits，运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。
- **GC分代年龄（age）**：占4bits，表示对象被GC的次数，在GC过程中，如果新生代对象在Survivor区复制一次，年龄+1．当对象年龄达到设定的阈值时，对象将会进入老年代．或者有一半的的对象年龄相等，则大于该年龄的对象直接进入老年代．默认情况GC年龄阈值为15．因为age只占4位 ，所以最大值为1 1 1 1 = 15．
- **锁标志位（lock）**：占2bits，区分锁状态，00-轻量锁，01-解锁或偏向锁，10-重量锁，11-GC标记
- **biased_lock**：占1bits，是否偏向锁，由于正常锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。

> 无锁和偏向锁的锁标志都是01 ，区分的方式是通过1bit的是否为偏向锁(biased_lock)．偏向锁的这1bit等于1，无锁这一位则为0

- **偏向锁的线程ID（JavaThread）**：占54bits，偏向锁记录的线程标识，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。

- **Epoch**：占2bits，偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。

- **ptr_to_lock_record**：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。

- **ptr_to_heavyweight_monitor**：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。

> 分析synchronize锁优化和JVM垃圾回收年龄代的时候会有很大作用



> JVM中大家是否还记得对象在Suvivor中每熬过一次MinorGC，年龄就增加1，当它的年龄增加到一定程度后就会被晋升到老年代中，这个次数默认是15岁，有想过为什么是15吗？在Mark Word中可以发现标记对象分代年龄的分配的空间是4bit，而4bit能表示的最大数就是2^4-1 = 15。



- #### **类型指针（class Pointer）**

> 未开启指针压缩时，类型指针占用8byte (64bit)
>
> 开启指针压缩情况下，类型指针占用4byte (32bit)

Class对象指针（指针压缩默认开启）的大小默认是4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址，保存在元空间。

前提：

new Object()在32为系统中占用内存大小是8byte（对象头，在堆中）+ 4byte（对象的引用地址，在栈中）=12byte；

new Object()在64为系统中占用内存大小是16byte（对象头，在堆中）+ 8byte（对象的引用地址，在栈中）=24byte；

> -XX:+UseCompressedOops  JVM 会使用 32-bit的offset来代表java object的引用
>
> -XX:+UseCompressedClassPointers  (默认是开启)     表示使用压缩指针，使用32-bit的offset来代表64-bit进程中的class pointer

总结：

1. 通过指针压缩，利用对齐填充的特性，通过映射方式达到了内存地址扩展的效果
2. 指针压缩能够节省内存空间，同时提高了程序的寻址效率
3. 堆内存设置时最好不要超过32GB，这时指针压缩将会失效，造成空间的浪费
4. 此外，指针压缩不仅可以作用于对象头的类型指针，还可以作用于引用类型的字段指针，以及引用类型数组指针
   

- #### **array length(数组特有)**

如果对象是一个数组，那么对象头还要有额外的空间存储数组的长度，JVM可以通过对象头中的数组长度数据来判定数组的大小，这是访问数组类型的元数据是无法得知的.　长度为4个字节

#### 不同情况下的Object Header

- 32位JVM下

```
|----------------------------------------------------------------------------------------|--------------------
|                                    Object Header (64 bits)                             |        State       
|-------------------------------------------------------|--------------------------------|--------------------
|                  Mark Word (32 bits)                  |      Klass Word (32 bits)      |                    
|-------------------------------------------------------|--------------------------------|--------------------
| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |     正常(无状态)   
|-------------------------------------------------------|--------------------------------|--------------------
|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |       偏向锁       
|-------------------------------------------------------|--------------------------------|--------------------
|               ptr_to_lock_record:30          | lock:2 |      OOP to metadata object    |       轻量锁       
|-------------------------------------------------------|--------------------------------|--------------------
|               ptr_to_heavyweight_monitor:30  | lock:2 |      OOP to metadata object    |       重量锁       
|-------------------------------------------------------|--------------------------------|--------------------
|                                              | lock:2 |      OOP to metadata object    |       GC标记       
|-------------------------------------------------------|--------------------------------|--------------------
```

- 64位JVM下

```
|----------------------------------------------------------------------------------------------------------|------------
|                                            Object Header (128 bits)                                      |    State
|------------------------------------------------------------------------------|---------------------------|------------
|                                  mark word (64 bits)                         |  klass word (64 bits)  |
|------------------------------------------------------------------------------|---------------------------|------------
| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |  OOP to metadata object   | 正常(无状态)
|------------------------------------------------------------------------------|---------------------------|------------
| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |  OOP to metadata object   |   偏向锁
|------------------------------------------------------------------------------|---------------------------|------------
|                       ptr_to_lock_record:62                         | lock:2 |  OOP to metadata object   |   轻量锁
|------------------------------------------------------------------------------|---------------------------|------------
|                     ptr_to_heavyweight_monitor:62                   | lock:2 |  OOP to metadata object   |   重量锁
|------------------------------------------------------------------------------|---------------------------|------------
|                                                                     | lock:2 |  OOP to metadata object   |   GC标记
|------------------------------------------------------------------------------|---------------------------|------------
```

- 64位JVM压缩指针

```
|---------------------------------------------------------------------------------------------------------|------------|
|                                            Object Header (96 bits)                                      |  State     |
|--------------------------------------------------------------------------------|------------------------|------------|
|                                  Mark Word (64 bits)                           | Klass Word (32 bits)   |            |
|--------------------------------------------------------------------------------|------------------------|------------|
| unused:25 | identity_hashcode:31 | cms_free:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 正常(无状态) |
|--------------------------------------------------------------------------------|------------------------|------------|
| thread:54 |       epoch:2        | cms_free:1 | age:4 | biased_lock:1 | lock:2 | OOP to metadata object | 偏向锁      |
|--------------------------------------------------------------------------------|------------------------|------------|
|                         ptr_to_lock_record                            | lock:2 | OOP to metadata object | 轻量锁      |
|--------------------------------------------------------------------------------|------------------------|------------|
|                     ptr_to_heavyweight_monitor                        | lock:2 | OOP to metadata object | 重量锁      |
|--------------------------------------------------------------------------------|------------------------|------------|
|                                                                       | lock:2 | OOP to metadata object | GC标记     |
|--------------------------------------------------------------------------------|------------------------|------------|
```



### 实例数据（Instance Data）

包括了对象的所有成员变量，分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers普通对象指针）。

- 基本数据类型

byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节

- 引用数据类型

reference开启UseCompressedOops占4字节，不开启UseCompressedOops占8字节

> -XX:+UseCompressedOops  为4字节(默认开启) ，不开启为8字节 Oops（Ordinary Object Pointers）(成员变量的引用 比如Object o)



### 对齐补充（Padding）

由于要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

> **为什么要对齐数据**？字段内存对齐的其中一个原因，是让字段只出现在同一CPU的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。其实对其填充的最终目的是为了计算机高效寻址



## 对象的创建过程

|                                                             |
| :---------------------------------------------------------: |
| <img src="image/Java/对象创建过程.png" style="zoom:80%;" /> |

#### 类加载

首先jvm要检查类A是否已经被加载到了内存，即类的符号引用是否已经在常量池中，并且检查这个符号引用代表的类是否已被加载、解析和初始化过的。如果还没有，需要先触发类的加载、解析、初始化，然后在堆上创建对象。



#### 分配内存

在类加载检查通过后，虚拟机将为新生对象分配内存。

##### 内存分配方式

1. **指针碰撞**

   如果Java堆中内存是**绝对规整**的，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为**“指针碰撞”（Bump The Pointer）**。

2. **空闲列表**

   如果Java堆中的内存并**不是规整**的，已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为**“空闲列表”（Free List）**。

> 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或 CMSFullGCsBeforeCompaction来整理内存），就通常采用空闲列表



##### 内存分配时处理并发安全问题

对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。

- CAS：失败重试，区域加锁，保证指针更新操作的原子性

- TLAB：（Thread Local Allocation Buffer）把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲区**，哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。

  

#### 完成实例数据部分的初始化工作（初始化为0值）

内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB的话，这一工作也可以提前至TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

| 类型                  | 默认值         |
| --------------------- | -------------- |
| byte                  | (byte)0        |
| short                 | (short)0       |
| int                   | 0              |
| long                  | 0L             |
| float                 | 0.0f           |
| double                | 0.0d           |
| boolean               | false          |
| char                  | '/uoooo'(null) |
| reference（引用类型） | null           |

#### 设置对象头

虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的**对象头（Object Header）**之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。



#### 执行\<init>方法

在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，初始化才正式开始，开始调用\<init>方法完成初始复制和构造函数，所有的字段都为零值。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执 行\<init>方法（**子类的< init >方法中会首先对父类< init >方法的调用**），把对象按照程序员的意愿进行初始化，然后将内存地址赋给栈内存中的变量，这样一个真正可用的对象才算完全创建出来。

> <init> 实例初始化方法，对象构造器方法。1.父类变量初始化块/父类语句块 2.父类构造函数 3.子类变量初始化块/子类语句块 4.子类构造函数。
>
> <client> 类初始化方法，类构造器方法。1.父类静态变量初始化/父类静态语句块 2.子类静态变量初始化/子类静态语句块。

```cpp
// 确保常量池中存放的是已解释的类
    if (!constants->tag_at(index).is_unresolved_klass()) {
      // 断言确保是klassOop和instanceKlassOop
      oop entry = (klassOop) *constants->obj_at_addr(index);
      assert(entry->is_klass(), "Should be resolved klass");
      klassOop k_entry = (klassOop) entry;
      assert(k_entry->klass_part()->oop_is_instance(), "Should be instanceKlass");
      instanceKlass* ik = (instanceKlass*) k_entry->klass_part();
      // 确保对象所属类型已经经过初始化阶段
      if ( ik->is_initialized() && ik->can_be_fastpath_allocated() ) {
        // 取对象长度
        size_t obj_size = ik->size_helper();
        oop result = NULL;
        // 记录是否需要将对象所有字段置零值
        bool need_zero = !ZeroTLAB;
        // 是否在TLAB中分配对象
        if (UseTLAB) {
          result = (oop) THREAD->tlab().allocate(obj_size);
        }
        if (result == NULL) {
          need_zero = true;
          // 直接在eden中分配对象
    retry:
          HeapWord* compare_to = *Universe::heap()->top_addr();
          HeapWord* new_top = compare_to + obj_size;
          // cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，并发失败的话，转到retry中重试直至成功分配为止
          if (new_top <= *Universe::heap()->end_addr()) {
            if (Atomic::cmpxchg_ptr(new_top, Universe::heap()->top_addr(), compare_to) != compare_to) {
              goto retry;
            }
            result = (oop) compare_to;
          }
        }
        if (result != NULL) {
          // 如果需要，为对象初始化零值
          if (need_zero ) {
            HeapWord* to_zero = (HeapWord*) result + sizeof(oopDesc) / oopSize;
            obj_size -= sizeof(oopDesc) / oopSize;
            if (obj_size > 0 ) {
              memset(to_zero, 0, obj_size * HeapWordSize);
            }
          }
          // 根据是否启用偏向锁，设置对象头信息
          if (UseBiasedLocking) {
            result->set_mark(ik->prototype_header());
          } else {
            result->set_mark(markOopDesc::prototype());
          }
          result->set_klass_gap(0);
          result->set_klass(k_entry);
          // 将对象引用入栈，继续执行下一条指令
          SET_STACK_OBJECT(result, 0);
          UPDATE_PC_AND_TOS_AND_CONTINUE(3, 1);
        }
      }
    }
```



## 对象的访问定位

​        需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用**句柄**和**直接指针**两种。 

- **句柄**

​        Java堆中将会划分出一块内存来作为**句柄池**，**reference**中存储的就是**对象的句柄地址**，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。

> 最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾回收时，内存地址发生变动）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。 

|                         句柄访问对象                         |
| :----------------------------------------------------------: |
| <img src="./image/Java/句柄访问对象.png" alt="句柄访问对象" style="zoom:80%;" /> |



- **直接指针**

　　**reference**中直接存储的对象地址， 对象实例数据中存储类型的指针地址。

> 最大的好处就是速度更快，它节省了一次**对象实例指针定位**的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。就虚拟机HotSpot而言，它是使用**直接指针**方式进行对象访问

|                       直接指针访问对象                       |
| :----------------------------------------------------------: |
| <img src="./image/Java/直接指针访问对象.png" alt="直接指针访问对象" style="zoom:80%;" /> |



## 锁的四种状态

|                                                            |
| :--------------------------------------------------------: |
| <img src="./image/Java/对象创建.png" style="zoom: 67%;" /> |
|                                                            |



- new (未锁定状态)
  在一个对象刚new出来的时候，没有线程竞争，就是一个普通对象，不需要加锁，此时biased_lock为1,锁的标志位为01 , 表示无锁可偏向 . ( 如果计算了对象的hashcode ,则会记录对象的hashcode，锁的标志位为01．biased_lock位置为0. 此时表示无锁不可偏向状态)

  
  
- 偏向锁：biased_lock
  如果已经计算了对象的hashcode ,则表示该锁不能偏向 .直接升级为轻量级锁.(对象的hashcode和偏向线程id只能存储一个)
  
  1. 当第一个线程A来获取资源的时候，这个时候只有线程A一个，没有其他线程来竞争，他会将biased_lock标志位置为1，锁标志为01, 表示已经偏向它的状态．线程ID也会记录A的id.
  2. 当A线程再次获取该资源的时候，JVM发现mark word里面的线程id是A的id，锁的标志位是01，biased_lock是1，表示A已经获得该偏向锁．

  

- 轻量级锁（自旋，自旋锁，look-free，CAS轻量级锁）：
  当线程B尝试获取该锁时（此时有了锁的竞争），JVM发现此时锁处于偏向状态，mark word的线程id记录的是A，此时线程B会尝试通过CAS的方式（在用户空间）获取锁．两个线程都将对象的hashcode复制到自己新建的用于存储锁的记录空间LockRecord，通过CAS的操作，将对象的mark word的内容修改为自己新建的记录空间的地址来竞争mark word．成功则获取资源，失败则继续CAS操作．
  自旋的线程在自旋过程中，成功获取资源，整个状态仍然处于轻量级锁的状态．

  
  
- 重量级锁：

> 竞争加剧 在jdk6: 自旋锁自旋次数超过10，或者等待线程超过CPU核数的二分之一，升级为重量级锁
> jdk6以后：jdk自适应自旋，来判断什么时候升级

自旋的线程将被阻塞，需经过os，提供一个等待队列和一个竞争队列．等待操作系统的调度



| 锁名称   |                             描述                             | 优点                                                         | 缺点                                           | 适用场景                           |
| -------- | :----------------------------------------------------------: | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |
| 偏向锁   | 线程在大多数情况下并不存在竞争条件，使用同步会消耗性能，而偏向锁是对锁的优化，可以消除同步，提升性能。当一个线程获得锁，会将对象头的锁标志位设为01，进入偏向模式.偏向锁可以在让一个线程一直持有锁，在其他线程需要竞争锁的时候，再释放锁 | 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景   |
| 轻量级锁 | 当线程A获得偏向锁后，线程B进入竞争状态，需要获得线程A持有的锁，那么线程A撤销偏向锁，进入无锁状态。线程A和线程B交替进入临界区，偏向锁无法满足，膨胀到轻量级锁，锁标志位设为00。 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程使用自旋会消耗CPU    | 追求响应时间。同步块执行速度非常快 |
| 重量级锁 | 当多线程交替进入临界区，轻量级锁hold得住。但如果多个线程同时进入临界区，hold不住了，膨胀到重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢                         | 追求吞吐量。同步块执行速度较长     |



## JSR内存屏障（Memory Barrier）

Java内存屏障主要有Load和Store两类。 
对Load Barrier来说，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据 
对Store Barrier来说，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存

| 屏障类型   | 指令示例                 | 说明                                                         |
| ---------- | ------------------------ | ------------------------------------------------------------ |
| LoadLoad   | Load1;Loadload;Load2     | 在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕 |
| StoreStore | Store1;StoreStore;Store2 | 在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见 |
| LoadStore  | Load1;LoadStore;Store2   | 在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕 |
| StoreLoad  | Store1;StoreLoad;Load2   | 在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见 |



- LoadLoad 屏障

  序列：Load1 -> Loadload -> Load2 

- StoreStore 屏障

  序列：Store1 -> StoreStore -> Store2 

- LoadStore 屏障

  序列：Load1 -> LoadStore -> Store2 

- StoreLoad 屏障

  序列：Store1 -> StoreLoad ->  Load2
  
  **它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能**



## Happens - Before原则

导致多线程间可见性问题的两个“罪魁祸首”是*CPU缓存*和*重排序*，JMM定义了Happens-Before原则：**对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。**

1. 程序顺序规则
2. 锁定规则
3. volatile变量规则
4. 线程启动规则
5. 线程结束规则
6. 中断规则
7. 终结器规则
8. 传递性规则

|                                                              |
| :----------------------------------------------------------: |
| <img src="./image/Java/Happens-Before.jpg" style="zoom: 80%;" /> |

如图所示，这里的unlock M和lock M就是划分程序的分割线。在这里，红色区域和绿色区域的代码内部是可以进行重排序的，但是unlock和lock操作是不能与它们进行重排序的。即第一个图中的红色部分必须要在unlock M指令之前全部执行完，第二个图中的绿色部分必须全部在lock M指令之后执行。并且在第一个图中的unlock M指令处，红色部分的执行结果要全部刷新到主存中，在第二个图中的lock M指令处，绿色部分用到的变量都要从主存中重新读取。
在程序中加入分割线将其划分成多个程序块，虽然在程序块内部代码仍然可能被重排序，但是保证了程序代码在宏观上是有序的。并且可以确保在分割线处，CPU一定会和主内存进行交互。Happens-Before原则就是定义了程序中什么样的代码可以作为分隔线。并且无论是哪条Happens-Before原则，它们所产生分割线的作用都是相同的。

> 如果A happen-before B，意味着A的执行结果必须对B可见，也就是保证跨线程的内存可见性。并不代表A一定在B之前执行。因为，对于多线程程序而言，两个操作的执行顺序是不确定的。happen-before 只确保如果A在B之前执行，则A的执行结果必须对B可见。定义了内存可见性的约束，也就定义了一系列重排序的约束。

## 



