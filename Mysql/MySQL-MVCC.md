# MySQL - MVCC

## MVCC

> 隔离性

**Multi-Version Concurrency Control** ，多版本并发控制，提高数据库并发性能，读写时，不加锁，非阻塞并发读；

在Mysql的InnoDB引擎中，在读已提交（Read Commited）和可重复读（Repeatable Read）两种隔离级别下对于select的操作会访问版本链中的记录过程。

- 当前读：读取的数据是最新版本，读取时还要保证其它并发事务不能修改当前记录，会对读取的记录进行加锁，像`select lock in share mode(共享锁)`, `select for update` ; `update`, `insert` ,`delete(排他锁)`
- 快照读：读取的数据是历史数据，可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

### 版本链

`InnoDB`存储引擎，它的聚簇索引记录中都包含两个必要的隐藏列（`db_row_id`并不是必要的，创建的表中有主键或者非NULL唯一键时都不会包含`db_row_id`列）

- `db_row_id`：数据库默认为该行记录生成的唯一隐式主键，6byte，如果数据表没有主键，会自动以db_row_id产生一个聚簇索引

- `db_trx_id`：最近修改（新增/更新）事务id，6byte，每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给`trx_id`隐藏列。 
- `db_roll_pointer`：回滚指针，7byte，指向这条记录的上一个旧版本，每次对某条聚簇索引记录进行改动时，都会把老版本写入到`undo log`中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。
- `deleted_bit`：1byte，记录被更新或被删除，并不是真的删除，删除flag变了

> Tips： 能不能在两个事务中交叉更新同一条记录呢？不可以，第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。

### undo log

![](.\image\MySQL\undo.png)

不同事务或相同事务对同一记录的修改，会导致`undo log`成为一条记录版本线性表，`undo log`链首就是最新的旧记录，链尾就是最早的旧记录。

### ReadView

事务进行**快照读**时产生的**读视图**，在该事务执行的**快照读**的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前**活跃事务的ID**（当每个事务开启时，都会被分配一个ID，这个ID是递增的，所以最新的事务，ID值越大）

`Read Uncommitted`隔离级别的事务，直接读取记录的最新版本。

`Serializable `隔离级别的事务，使用加锁的方式访问记录。

只在`Read Committed`、 `Repeatable Read`隔离级别的事务，在执行普通的`SELECT`操作时访问记录的版本链的过程，使不同事务的读-写、写-读操作并发执行。

> Tips： 事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的`trx_id`，这个事务id是递增的。

两者不同在生成`ReadView`的时机，`Read Committed`每一次进行`SELECT`操作前都会生成一个`ReadView`；而`Repeatable Read`只在第一次进行`SELECT`操作前生成一个`ReadView`，之后的查询操作都重复这个`ReadView`

|                |                                                              |
| -------------- | ------------------------------------------------------------ |
| m_ids          | 生成ReadView时当前系统活跃的读写事务的事务id列表             |
| up_limit_id    | 生成ReadView时当前系统活跃的读写事务中的最小的事务id         |
| low_limit_id   | 生成ReadView时当前系统应该分配给下一个事务的id，也就是目前出现过的事务ID的最大值+1 |
| creator_trx_id | 生成ReadView时事务id                                         |

#### 判断版本链中版本可用

- trx_id == creator_trx_id：可以访问这个版本
- trx_id  <  up_limit_id：可以访问这个版本
- trx_id  >=  low_limit_id：不可以访问这个版本
- up_limit_id  <=  trx_id  <  low_limit_id：如果trx_id在m_ids中，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

ReadView中主要就是有个列表（m_ids）来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。

a) 如果你要访问的记录版本的事务id为50，比当前列表最小的id（up_limit_id）80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。

b) 如果你要访问的记录版本的事务id为90，发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。

c) 如果你要访问的记录版本的事务id为110，那比事务列表最大id（low_limit_id）100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。

这些记录都是去undo log 链里面找的，先找最近记录，如果最近这一条记录事务id不符合条件，不可见的话，再去找上一个版本再比较当前事务的id和这个版本事务id看能不能访问，以此类推直到返回可见的版本或者结束。

![](.\image\MySQL\MVCC.png)