# Redis-缓存问题

## 缓存问题隐患

### 多线程

- 线程模型：

Reactor模式，非阻塞IO多路复用机制



### 缓存穿透

​		正常情况下，查询的数据都存在，如果请求一个不存在的数据，也就是**缓存和数据库都查不到这个数据**，每次都会去数据库查询，这种**查询不存在数据的现象**我们称为缓存穿透（透心凉）

​		**缓存中无，DB中也无**

解决办法：

- 接口层增加校验：比如鉴权、参数校验，不合法的直接return
- 缓存空值，但过期时间TTL很短
- BloomFilter布隆过滤器



### 缓存击穿

​		在高并发的情况下，大量的请求同时查询同一个key时，此时这个key正好失效了，就会导致同一时间，这些请求都会去查询数据库，这样的现象我们称为缓存击穿

​		**缓存中无，但是DB中有**

​		会造成某一时刻数据库请求量过大

解决办法：

- 热点数据永不过期
- 互斥锁，在第一个查询数据的请求上使用一个锁，其它的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。
- 逻辑过期



### 缓存雪崩

​		当某一时刻发生大规模的缓存失效的情况，比如缓存服务宕机了，会有大量的请求进来直接打到DB上面，导致DB挂了

解决方案：

- 搭建异地多活、集群
- 缓存时间设置业务过期时间 + 随机值
- 缓存数据预热（提前将可能大量访问的数据加载到缓存中，可以手动触发加载）
- 互斥锁
- ehcache本地缓存 + 限流&降级组件
- 多级缓存



### 热点数据集中失效

对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。

设置不同的失效时间（在一个基础的时间上加上或者减去一个范围内的随机值）

互斥锁



### 大key

value比较大，string类型控制在10kb以内，集合元素个数不要超过N。

一直往value塞数据，没有删除或过期机制；数据没有合理做分片，将大key变成一个个小key。

导致客户端超时阻塞、内存空间不均匀、网络阻塞。

#### 如何检测？

scan

`memory usage keyname`

**redis-rdb-tools**，解析快照文件，执行bgsave时对dump出来的rdb文件进行分析。

#### 如何删除？

主动删除

分批渐进式删除

unlink + bigKey 异步非阻塞删除

被动删除，配置`lazy free`

#### 如何优化？

1. 只存储有用字段
2. 对value进行压缩
3. 可以使用不同关联的key进行存储
4. 大key 分拆成几个 key-value
5. 集群扩容
6. 集合数据类型，hash类型，拆分新的newHashKey，设置一个桶值bucket，filed值对bucket取余

```
newHashKey = hashKey + (filed) % bucket
hmset(newHashKey)
hmget(newHashKey)
```



### 热点key

极短时间内访问频次非常高的key

#### 产生原因

- 比如秒杀活动、热点微博、热评，某件商品被数万次点击浏览或购买时，就会造成热点问题

- 被大量发布、浏览的热点新闻、热点评论等读多写少场景也会产生热点问题


#### 产生危害

1. 占用大量CPU，性能变差，影响其它请求，请求过多，服务器被打垮
2. 分片集中，引起节点数据倾斜
3. 超出服务承受能力造成缓存击穿，造成DB宕机

#### 如何发现

- 热key检测系统
- proxy代理层上报数据
- 4.0+版本hotkeys，`redis-cli --hotkeys`
- redis节点抓包解析上报数据

#### 如何解决

1. 使用本地缓存
2. 冗余备份key，拆key，将key拆分成N份，分散在不同的节点上
3. 限流熔断（保护系统）**nginx限流**、应用网关限流、**微服务限流**

京东开源的hotkey

### Redis分布式锁

#### 可重入

#### 可重试

#### 超时释放

#### 主从一致性

联锁，多个独立锁，`RLock getMultiLock(RLock... locks)`



### 缓存数据库双写不一致

- 延迟双删

- 内存队列
- 读写锁（分布式）



### 慢查询

#### 客户端

1. 连接池过小引起的阻塞

   如果连接池配置了较小连接数，不能满足业务高QPS的需求的话，可能导致经常无法获取到空闲连接，此时如果blockWhenExhausted=true的话，就会在获取连接时阻塞等待，表现在业务接口中，就是接口耗时增加。也可能会无法获取到连接，在客户端抛出无法获取连接的异常。

2. 连接池伸缩引起的性能损耗

   创建连接是个较耗时的操作，如果连接池配置maxTotal > maxIdle，可能会在请求量大时经常创建新的连接。频繁的创建、销毁连接，会带来性能损耗。

#### 服务端

1. 慢查询

   在慢查询日志中，可以查看到处理时间超过`slowlog-log-slower-than`（可配置）微秒的命令

2. 大量的key同时过期引起的阻塞

   打散过期时间

3. AOF rewrite引起的阻塞

   AOF重写需要fork子进程

### 内存不足

- 数据内存：存储键值信息，主要是BigKey问题、内存碎片

- 进程内存：

- 缓冲区内存：客户端缓冲区（）输入和输出缓冲区、AOF缓冲区（AOF刷盘之前的缓存区域，执行rewrite的缓冲区）、复制缓冲区（主从复制的repl_backlog_buf）。

#### 查看内存分配情况

- `info memory`
- `memory xxxx`

### 连接池设置建议

| 参数名                        | 资源池中最大连接数                                           | 默认值           | 使用建议                                                     |
| ----------------------------- | ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ |
| maxTotal(maxActive）          | 资源池中最大连接数                                           | 8                | 建议根据需要设置( qps/主节点数/ (1000/每条命令的预计耗时ms)*(3/2))与maxIdle、minIdle相同，且不超过业务线程数量 |
| maxIdle                       | 资源池允许最大空闲的连接数                                   | 8                | 同上                                                         |
| minIdle                       | 资源池允许最小空闲的连接数                                   | 8                | 同上                                                         |
| blockWhenExhausted            | 资源池资源耗尽时，是否等待                                   | true             |                                                              |
| maxWaitMillis(maxWait)        | 当资源池连接用尽后，调用者的最大等待时间(单位为毫秒)         | -1：表示永不超时 | 根据需要确认最大等待时间                                     |
| jmxEnable                     | 是否开启JMX                                                  | true             | true                                                         |
| testOnBorrow                  | 向资源池借用连接时是否做连接有效性检测(ping)，无效连接会被移除 | false            | false                                                        |
| testOnReturn                  | 向资源池归还连接时是否做连接有效性检测(ping)，无效连接会被移除 | false            | false                                                        |
| testWhileIdle                 | 是否开启空闲资源监测                                         | false            | true                                                         |
| timeBetweenEvictionRunsMillis | 空闲资源的检测周期(单位为毫秒)                               | -1:不检测        | 建议设置，可以使用JedisPoolConfig中的配置                    |
| minEvictableIdleTimeMillis    | 资源池中资源最小空闲时间(单位为毫秒)，达到此值后空闲资源将被移除 | 30分钟           | 大部分情况下默认值即可，也可以参考JedisPoolConfig的配置      |
| numTestsPerEvictionRun        | 做空闲资源检测时，每次的采样数                               | 3                | 可根据自身应用连接数进行微调,如果设置为-1，就是对所有连接做空闲监测 |

1. 缩短键值对的存储长度；**序列化我们可以使用 protostuff 或 kryo，压缩我们可以使用 snappy。**

2. 使用 lazy free（延迟删除）特性；

   4.0版本

   ```
   lazyfree-lazy-eviction no     # 超过最大内存惰性删除
   lazyfree-lazy-expire no       # 过期惰性删除
   lazyfree-lazy-server-del no   # 服务端被动惰性删除
   slave-lazy-flush no           # slave接收完RDB文件后清空数据选项
   ```

3. 设置键值的过期时间；

4. 禁用长耗时的查询命令；

5. 使用 **slowlog** 优化耗时命令；

   ```
   slowlog-log-slower-than:1000， 用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒 (1 秒等于 1000000 微秒)；
   slowlog-max-len:128， 用来配置慢查询日志的最大记录数。
   ```

6. 使用 Pipeline 批量操作数据；

7. 避免大量数据同时失效；**过期时间的基础上添加一个指定范围的随机数**

8. 客户端使用优化；**Pipeline和连接池**

9. 限制 Redis 内存大小；

10. 使用物理机而非虚拟机安装 Redis 服务；

11. 检查数据持久化策略；
    - RDB 快照         内存快照
    - AOF 文件追加  文件形式
    - 混合 在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。

```
aof-use-rdb-preamble  4.0版本提供
```

12. 禁用 THP 特性；

13. 使用分布式架构来增加读写速度。